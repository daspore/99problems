{
    "1": {
        "description": "Find the last element of a list.",
        "difficulty": 1,
        "function-name": "last",
	"category": "Lists",
	"abstract-example": "\\( (x_1,x_2,\\ldots,x_n)\\mapsto x_n \\)",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "10"},
				{"input": "FN \"abc\"", "output": "'c'"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = 4"},
				{"input": "FN([a,b,c],X).", "output": "X = c"}
			]
		}
	}
    },
    "2": {
        "description": "Find the next-to-the-last element of a list.",
        "difficulty": 1,
        "function-name": "penultimate",
	"category": "Lists",
	"abstract-example": "\\( (x_1,x_2,\\ldots,x_{n-1},x_n)\\mapsto x_{n-1} \\)",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "9"},
				{"input": "FN \"abc\"", "output": "'b'"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = 3"},
				{"input": "FN([a,b,c],X).", "output": "X = b"}
			]
		}
	}
    },
    "3": {
        "description": "Find the \\(k\\)th element of a list. The first element in the list is number 0.\n",
        "difficulty": 1,
        "function-name": "element at index",
	"abstract-example": "\\( k, (x_0,x_1,\\ldots,x_n)\\mapsto x_{k} \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 2 [0..10]", "output": "2"},
				{"input": "FN 1 \"abc\"", "output": "'b'"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(2,[0,1,2,3,4],X).", "output": "X = 2"},
				{"input": "FN(1,[a,b,c],X).", "output": "X = b"}
			]
		}
	}
    },
    "4": {
        "description": "Find the number of elements of a list.\n",
        "difficulty": 1,
        "function-name": "length",
        "example": "",
	"abstract-example": "\\( (x_1,\\ldots,x_n)\\mapsto n \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "10"},
				{"input": "FN \"abc\"", "output": "3"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = 4"},
				{"input": "FN([a,b,c],X).", "output": "X = 3"}
			]
		}
	}
    },
    "5": {
        "description": "Reverse a list.\n",
        "difficulty": 1,
        "function-name": "reverse",
	"abstract-example": "\\( (x_1,x_2,\\ldots,x_{n-1},x_n)\\mapsto  (x_n,x_{n-1},\\ldots,x_{2},x_1)\\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]"},
				{"input": "FN \"abc\"", "output": "\"cba\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = [4,3,2,1]"},
				{"input": "FN([a,b,c],X).", "output": "X = [c,b,a]"}
			]
		}
	}
    },
    "6": {
        "description": "Find out whether a list is a palindrome. A palindrome can be read forward or backward. For example \"xamax\".",
        "difficulty": 1,
        "function-name": "palindromic",
	"abstract-example": "\\( (x_1,x_2,\\ldots,x_{n-1},x_n)\\mapsto \\mathbf{True} \\) if \\(x_i=x_{n-1}\\) and \\(\\mathbf{False}\\) otherwise.",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"abc\"", "output": "False"},
				{"input": "FN \"abcba\"", "output": "True"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4]).", "output": "no"},
				{"input": "FN([a,b,c,b,a]).", "output": "yes"}
			]
		}
	}
    },
    "7": {
        "description": "Flatten a nested list structure.\n",
        "difficulty": 2,
        "function-name": "flatten",
	"abstract-example": "\\( \\big(x_1,(x_2,x_3),((x_4,\\ldots\\big)\\mapsto (x_1,x_2,x_3,x_4,\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell's type system requires lists to be homogeneous (they must have the exact same type). So you cannot define arbitrarily nested lists. For this problem, you will need to define a data type that simulates nested lists. Use: <code class='code'>data NestedList a = Elem a | List [NestedList a]</code>"
			],
			"examples": [
				{"input": "FN (Elem 1)", "output": "[1]"},
				{"input": "FN (List [Elem 1, List [List [], Elem 2, List [Elem 3]], Elem 4])", "output": "[1,2,3,4]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(1,X).", "output": "X = [1]"},
				{"input": "FN([1,[[],2,[3]],4],X).", "output": "X = [1,2,3,4]"}
			]
		}
	}
    },
    "8": {
        "description": "Eliminate consecutive duplicates of list elements.\n",
        "difficulty": 2,
        "function-name": "deduplicate",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto (a,b,a,c,\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "\"abcade\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = [1,2,3,4]"},
				{"input": "FN([a,a,a,b,a,a,c,c,c,c,b],X).", "output": "X = [a,b,a,c,b]"}
			]
		}
	}
    },
    "9": {
        "description": "Pack consecutive duplicates of list elements into sublists.\nIf a list contains repeated elements they should be placed in separate sublists.\n",
        "difficulty": 2,
        "function-name": "pack duplicates",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto \\big((a,a,a),(b),(a,a),(c,c,c),\\ldots\\big) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "[\"aaaa\",\"b\",\"cc\",\"aa\",\"d\",\"eeee\"]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([a,a,a,a,b,c,c,a,a,d,e,e,e,e],X).", "output": "X = [[a,a,a],[b],[c,c],[a,a],[d],[e,e,e,e]]"}
			]
		}
	}
    },
    "10": {
        "description": "Runlength encoding of a list.\nUse the result of earlier problems to implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as lists \\((e,n)\\) where \\(e\\) is the value of the element and \\(n\\) is the number of duplicates.\n",
        "difficulty": 1,
        "function-name": "runlength encode",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto \\big((a,3),(b,1),(a,2),(c,3),\\ldots\\big) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "[('a',3),('b',1),('c',2),('a',2),('d',1),('e',4)]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([a,a,a,a,b,c,c,a,a,d,e,e,e,e],X).", "output": "X = [[a,3],[b,1],[c,2],[a,2],[d,1],[e,4]]"}
			]
		}
	}
    },
    "11": {
        "description": "Modified run-length encoding.\nModify the result of problem 10 in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as \\((e,n)\\) lists.",
        "difficulty": 1,
        "function-name": "runlength encode b",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto \\big((a,3),b,(a,2),(c,3),\\ldots\\big) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell's type system requires lists to be homogeneous (they must have the exact same type), so you must create a new datatype which may be accomplished with: <code class='code'>data RunLen a = Single a | Multiple Int a    deriving Show</code>"
			],
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "[(Multiple 'a' 3),(Single 'b'),(Multiple 'c' 2),(Multiple 'a' 2),(Single 'd'),(Multiple 'e' 4)]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([a,a,a,a,b,c,c,a,a,d,e,e,e,e],X).", "output": "X = [[a,3],b,[c,2],[a,2],d,[e,4]]"}
			]
		}
	}
    },
    "12": {
        "description": "Decode a run-length encoded list.\nThis should undo the encoding from problem 11.",
        "difficulty": 2,
        "function-name": "runlength decode",
	"abstract-example": "\\( \\big((a,3),b,(a,2),(c,3),\\ldots\\big) \\mapsto (a,a,a,b,a,a,c,c,c,\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "[(Multiple 'a' 3),(Single 'b'),(Multiple 'c' 2),(Multiple 'a' 2),(Single 'd'),(Multiple 'e' 4)]", "output": "FN \"aaaabccaadeeee\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([[a,3],b,[c,2],[a,2],d,[e,4]],X).", "output": "X = [a,a,a,a,b,c,c,a,a,d,e,e,e,e]"}
			]
		}
	}
    },
    "13": {
        "description": "(**) Run-length encoding of a list (direct solution). \n",
        "difficulty": 2,
        "function-name": "",
        "example": "",
	"category": "Lists",
        "language-overrides": {}
    },
    "14": {
        "description": "Double each element of a list.\n",
        "difficulty": 1,
        "function-name": "double",
	"abstract-example": "\\( (x_1,x_2,x_3,\\ldots)\\mapsto (x_1,x_2,x_2,x_2,x_3,x_3,\\ldots) \\)",
        "example": "",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..4]", "output": "[1,1,2,2,3,3,4,4]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,a,b,c],X).", "output": "X = [1,1,2,2,3,3,a,a,b,b,c,c]"}
			]
		}
	}
    },
    "15": {
        "description": "Repeat each element of a list a given number of times.\n",
        "difficulty": 2,
        "function-name": "repeat",
	"abstract-example": "\\( k,(x_1,x_2,\\ldots)\\mapsto (\\underbrace{x_1,\\ldots,x_1}_{k},\\underbrace{x_2,\\ldots,x_2}_{k},\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..4]", "output": "[1,1,1,2,2,2,3,3,3,4,4,4]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,a,b,c],X).", "output": "X = [1,1,1,2,2,2,3,3,3,a,a,a,b,b,b,c,c,c]"}
			]
		}
	}
    },
    "16": {
        "description": "Drop every \\(k\\)th element from a list.\n",
        "difficulty": 2,
        "function-name": "drop sequence",
	"abstract-example": "\\( k,(x_1,x_2,\\ldots)\\mapsto (x_1,x_2,\\ldots,x_{k-1},x_{k+1},\\ldots,x_{2k-1},x_{2k+1},\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "[1,2,4,5,7,8,10]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [1,2,4,5,7,8,10]"}
			]
		}
	}
    },
    "17": {
        "description": "When given a length, split a list into two parts with the first part being of the specified length.\n",
        "difficulty": 1,
        "function-name": "split",
	"abstract-example": "\\( k,(x_1,x_2,\\ldots,x_n)\\mapsto (x_1,x_2,\\ldots,x_{k}),(x_{k+1},\\ldots,x_{n}) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "([1,2,3],[4,5,6,7,8,9,10])"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X,Y).", "output": "X = [1,2,3], Y = [4,5,6,7,8,9,10]"}
			]
		}
	}
    },
    "18": {
        "description": "Extract a slice from a list. Given numbers \\(i\\) and \\(j\\), return a sublist consisting of elements whose indices are between \\(i\\) and \\(j\\).",
        "difficulty": 2,
        "function-name": "slice",
        "abstract-example": "\\( i, j, (x_1,x_2,\\ldots,x_n)\\mapsto (x_i,x_{i+1},\\ldots,x_{j}) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 7 [1..10]", "output": "[3,4,5,6,7]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,7,[1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [3,4,5,6,7]"}
			]
		}
	}
    },
    "19": {
        "description": "Rotate a list \\(k\\) places to the left.\n",
        "difficulty": 2,
        "function-name": "roll",
        "abstract-example": "\\( k, (x_0,x_2,\\ldots,x_n)\\mapsto (x_k,x_{k+1},\\ldots,x_{n}, x_0,x_1,\\ldots,x_{k-1}) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "[4,5,6,7,8,9,10,1,2,3]"},
				{"input": "FN (-2) \"abcdef\"", "output": "\"efabcd\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [4,5,6,7,8,9,10,1,2,3]"},
				{"input": "FN(-2,[a,b,c,d,e,f],X).", "output": "X = [e,f,a,b,c,d]"}
			]
		}
	}
    },
    "20": {
        "description": "Remove the \\(k\\)th element from a list and return that element and the list with that element removed.\n",
        "difficulty": 1,
        "function-name": "pluck",
        "abstract-example": "\\( k, (x_0,x_2,\\ldots,x_n)\\mapsto x_k, (x_0,\\ldots,x_{k-1},x_{k+1},\\ldots,x_n) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "(3,[1,2,4,5,6,7,8,9,10])"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X,Y).", "output": "X = 3, Y = [1,2,4,5,6,7,8,9,10]"}
			]
		}
	}
    },
    "21": {
        "description": "Insert an element at a given position into a list.\n",
        "difficulty": 1,
        "function-name": "insert",
        "abstract-example": "\\( k,e, (x_0,x_2,\\ldots,x_n)\\mapsto x_k, (x_0,\\ldots,x_{k-1},e,x_{k},x_{k+1},\\ldots,x_n) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 15 [1..10]", "output": "[1,2,15,3,4,5,6,7,8,9,10]"},
				{"input": "FN 5 'x' \"abcdef\"", "output": "\"abcdxef\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,15,[1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [1,2,15,3,4,5,6,7,8,9,10]"},
				{"input": "FN(5,x,[a,b,c,d,e,f],X).", "output": "[a,b,c,d,x,e,f]"}
			]
		}
	}
    },
    "22": {
        "description": "Create a list containing all integers within a given range.\n",
        "difficulty": 1,
        "function-name": "range",
        "abstract-example": "\\( i, j\\mapsto (i, i+1, \\ldots, j-1, j) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 8", "output": "[3,4,5,6,7,8]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,8,X).", "output": "X = [3,4,5,6,7,8]"}
			]
		}
	}
    },
    "23": {
        "description": "Extract a given number of randomly selected elements from a list. \n",
        "difficulty": 2,
        "function-name": "take random",
        "abstract-example": "\\( i, (x_1,\\ldots,x_n)\\mapsto (x_{a_1}, x_{a_2}, \\ldots, x_{a_i}) \\) where \\((a_k)_{k=1,\\ldots, i}\\) is a random sequence with no repetitions.",
	"category": "Lists",
        "language-overrides": {}
    },
    "24": {
        "description": "Lotto: Draw \\(k\\) different random numbers from the set \\(1,2,\\ldots, n\\).\n",
        "difficulty": 1,
        "function-name": "lotto",
	"abstract-example": "\\( i,n \\mapsto ({a_1}, {a_2}, \\ldots, {a_i}) \\) where \\((a_k)_{k=1,\\ldots, i}\\) is a random sequence of integers with no repetitions satisfying \\(1\\leq a_k\\leq n\\).",
	"category": "Lists",
        "language-overrides": {}
    },
    "25": {
        "description": "Generate a random permutation of the elements of a list.\n",
        "difficulty": 1,
        "function-name": "permute",
        "abstract-example": "\\( (x_1,\\ldots,x_n)\\mapsto (x_{a_1}, x_{a_2}, \\ldots, x_{a_n}) \\) where \\((a_k)_{k=1,\\ldots, n}\\) is a random permutation of \\(1,2,\\ldots,n\\).",
	"category": "Lists",
        "language-overrides": {}
    },
    "26": {
        "description": "Generate all combinations of \\(k\\) elements from a list.  For example, you might want to find all possible committees of size 3 from a list of names of size 12.  There would be 220 such possibilities since the order of the comittee doesn't matter for combinations.  You can read more about combinations at <a href='https://en.wikipedia.org/wiki/Combination'>Wikipedia: Combinations</a>.",
        "difficulty": 2,
        "abstract-example": "\\( k, (x_1,\\ldots,x_n)\\mapsto \\big((x_1,\\ldots,x_k), (x_1,x_3,\\ldots,x_{k+1}),(x_1,x_2,x_4,\\ldots,x_{k+1}),\\ldots  \\big)\\)",
        "function-name": "combinations",
	"category": "Lists",
        "language-overrides": {}
    },
    "27a": {
        "description": "List every way that a set of size 9 can be split into disjoint groups of sizes 2,3, and 4.",
        "difficulty": 2,
        "function-name": "group234",
        "abstract-example": "\\( (x_1,\\ldots,x_9)\\mapsto \\big([(x_1,x_2),(x_3,x_4,x_5),(x_6,\\ldots,x_9)], [(x_1,x_3),(x_2,x_4,x_5),(x_6,\\ldots,x_9)], \\ldots \\big)\\)",
	"category": "Lists",
        "language-overrides": {}
    },
    "27b": {
        "description": "Given a list of sizes \\((a,b,c,\\ldots)\\), list every way that a set of size \\(k\\) can be split into disjoint groups of sizes \\(a,b,c,\\ldots\\).",
        "difficulty": 2,
        "function-name": "group",
	"category": "Lists",
        "language-overrides": {}
    },
    "28a": {
        "description": "Sort a list of lists according to length of sublists.\n",
        "difficulty": 2,
        "function-name": "sort by length",
        "abstract-example": "\\( (L_1,\\ldots,L_n)\\mapsto (L_{a_1},\\ldots,L_{a_n})\\) satisfying \\(|L_{a_i}|\\leq |L_{a_j}|\\) whenever \\(i\\leq j\\).",
	"category": "Lists",
        "language-overrides": {}
    },
    "28b": {
        "description": "Sort a list of lists according the frequency with which the length of the list appears.\n",
        "difficulty": 2,
        "function-name": "sort by length frequency",
        "abstract-example": "\\( (L_1,\\ldots,L_n)\\mapsto (L_{a_1},\\ldots,L_{a_n})\\) satisfying \\(\\#\\{k:|L_{k}|=|L_{a_i}|\\}\\leq \\#\\{k:|L_{k}|=|L_{a_j}|\\}\\) whenever \\(i\\leq j\\).",
	"category": "Lists",
        "language-overrides": {}
    },
    "31": {
        "description": "Determine whether a given positive integer number is prime.\n",
        "difficulty": 2,
        "function-name": "prime",
        "abstract-example": "\\( n\\mapsto \\mathbf{True}\\) if \\(n\\) is prime and \\(\\mathbf{False}\\) otherwise.",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "32": {
        "description": "Determine the greatest common divisor of two integers. Use <a href='http://en.wikipedia.org/wiki/Euclidean_algorithm'>Euclid's algorithm</a>.\n",
        "difficulty": 2,
        "function-name": "gcd",
        "abstract-example": "\\( a,b\\mapsto k\\) satisfying \\(k\\geq 0\\) and for any \\(d\\) so that \\(d| a\\) and \\(d| b\\) then \\(d| k\\).",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "33": {
        "description": "Determine whether two positive integer numbers are coprime. Two numbers are coprime if their greatest common divisor equals 1.\n",
        "difficulty": 1,
        "function-name": "coprime",
        "abstract-example": "\\( a,b\\mapsto \\mathbf{True}\\) if \\(\\mathrm{gcd}(a,b)=1\\) and \\(\\mathbf{False}\\) otherwise.",
        "language-overrides": {}
    },
    "34": {
        "description": "Calculate Euler's totient function \\(\\phi(n)\\).  That is, the number of integers in the range \\(1,2,\\ldots,n\\) that are relatively prime to \\(n\\).",
        "difficulty": 2,
        "function-name": "totient",
        "abstract-example": "\\( \\displaystyle n\\mapsto \\sum_{\\substack{1\\leq i\\leq n\\\\\\mathrm{gcd}(i,n)=1}} 1\\)",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "35": {
        "description": "List the prime factors of a given positive integer in ascending order, repeating factors if they occur multiple times.",
        "difficulty": 2,
        "function-name": "factor",
        "abstract-example": "\\( n\\mapsto (p_1,p_2,\\ldots,p_k)\\) satisfying that \\(p_i\\) is prime for all \\(i\\), \\(p_i\\leq p_j\\) if \\(i\\leq j\\), and \\(\\displaystyle n=p_1p_2\\cdots p_k\\).",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "36": {
        "description": "List the prime factors of a given number and their multiplicity.",
        "difficulty": 2,
        "function-name": "factors",
        "abstract-example": "\\( n\\mapsto \\big((p_1,a_1),(p_2,a_2),\\ldots,(p_k,a_k)\\big)\\) satisfying that \\(p_i\\) is prime for all \\(i\\), \\(p_i\\leq p_j\\) if \\(i\\leq j\\), and \\(n=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}\\).",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "37": {
        "description": "Calculate Euler's totient function \\(\\phi(n)\\) using the efficient formula \\[\\phi(n)=(p_1-1)p_1^{a_1-1}(p_2-1)p_2^{a_2-1}\\cdots(p_k-1)p_k^{a_k-1}\\] where \\(n=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}\\) is the prime factorization of \\(n\\).",
        "difficulty": 2,
        "function-name": "efficient totient",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "38": {
        "description": "(*) Compare the two methods of calculating Euler's totient function.\n",
        "difficulty": null,
        "function-name": "",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "39": {
        "description": "List all prime numbers in a given range.",
        "difficulty": 1,
        "function-name": "primes",
        "abstract-example": "\\( i,j\\mapsto (p_1,p_2,\\ldots, p_k)\\) where \\(i\\leq p_n\\leq j\\) exhaustively list the primes between \\(i\\) and \\(j\\).",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "40": {
        "description": "Goldbach's conjecture states that any <i>even</i> integer greater than 2 can be written as the sum of two primes.  For example, \\(28=5+23\\).  This conjecture has not been proved, but has been verified up to very large numbers.  Given a number, write it as the sum of two primes.",
        "difficulty": 2,
        "function-name": "goldbach",
        "abstract-example": "\\( 2n\\mapsto p_1,p_2\\) where \\(p_1,p_2\\) are prime and \\(2n=p_1+p_2\\).",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "41": {
        "description": "Given a range of integers by its lower and upper limit, print a list of all even numbers and their Goldbach composition.\n",
        "difficulty": 2,
        "function-name": "goldbach range",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "46": {
        "description": "Define binary functions for and, or, nand, nor, xor, implies, and equivalent (for logical equivalence) which succeed or fail according to the result of their respective operations; e.g. and(A,B) will succeed, if and only if both A and B succeed.\n  Given a composition of binary operators that it itself a binary operator, make a truth table for it.",
        "difficulty": 2,
        "function-name": "binary truth table",
	"category": "Logic and Codes",
        "language-overrides": {}
    },
    "47": {
        "description": "Modify the functions from 46 so they may be used as infix operators.\n",
        "difficulty": 1,
        "function-name": "",
	"category": "Logic and Codes",
        "language-overrides": {}
    },
    "48": {
        "description": "Given \\(n\\) variables and an \\(n\\)-ary boolean operator, construct a truth table.\n",
        "difficulty": 2,
        "function-name": "truth table",
	"category": "Logic and Codes",
        "language-overrides": {}
    },
    "49": {
        "description": "Gray codes.  A Gray code of length \\(n\\) is a list of all \\(n\\) bit sequences satisfying the property that adjacent elements in the list differ by exactly one bit.  Read about Gray codes <a href='https://en.wikipedia.org/wiki/Gray_code'>on Wikipedia</a> and then enumerate Gray codes of length \\(n\\)",
        "difficulty": 2,
        "function-name": "gray",
	"category": "Logic and Codes",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3", "output": "[\"000\",\"001\",\"011\",\"010\",\"110\",\"111\",\"101\",\"100\"]"}
			]
		}
	}
    },
    "50": {
        "description": "Huffman codes.  Given a list of items and their frequency, a Huffman dictionary (or Huffman code) is a way to assign items to bit-strings in a maximally-efficient way.  A consequence is that if an item appears more frequently, its bit-string representation is shorter.  You can read about Huffman encoding <a href='https://en.wikipedia.org/wiki/Huffman_coding'>on Wikipedi</a> or watch a video <a href='https://www.youtube.com/watch?v=ZdooBTdW5bM'>on YouTube</a> about how to build a Huffman dictionary.",
        "difficulty": 3,
        "abstract-example": "\\( (e_1,f_1), (e_2,f_2),\\ldots \\mapsto (e_1,c_1), (e_2,c_2),\\ldots\\) where \\(e_i\\) are items, \\(f_i\\) is the frequency of \\(e_i\\) and \\(c_i\\) is the Huffman code corresponding to \\(e_i\\).",
        "function-name": "huffman dictionary",
	"category": "Logic and Codes",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [('a',45),('b',13),('c',12),('d',16),('e',9),('f',5)]", "output": "[('a',\"0\"),('b',\"101\"),('c',\"100\"),('d',\"111\"),('e',\"1101\"),('f',\"1100\")]"}
			]
		}
	}
    },
    "54A": {
        "description": "(*) Check whether a given term represents a binary tree\n",
        "difficulty": 1,
        "function-name": "",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "55": {
        "description": "Enumerate balanced binary trees.  In a completely balanced binary tree, the following property holds for every node: The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, which means their difference is not greater than one.",
        "difficulty": 2,
        "function-name": "balanced trees",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"notes": [
				"In Haskell you can create a tree data-structure with <code class='code'>data Tree a = Empty | Branch a (Tree a) (Tree a)    deriving Show</code>"
			],
			"examples": [
				{"input": "FN 1", "output": "[Branch 0 Empty Empty]"},
				{"input": "FN 2", "output": "[Branch 0 (Branch 0 Empty Empty) Empty,Branch 0 Empty (Branch 0 Empty Empty)]"},
				{"input": "FN 4", "output": "[Branch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 Empty Empty),Branch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 Empty Empty),Branch 0 (Branch 0 Empty Empty) (Branch 0 (Branch 0 Empty Empty) Empty),Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty (Branch 0 Empty Empty))]"}
			]
		}
	}
    },
    "56": {
        "description": "Determine whether a given binary tree is symmetric.  A binary tree is symmetric if, cutting at the root the left side is a reflection of the right side.",
        "difficulty": 2,
        "function-name": "symmetric tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"notes": [
				"In Haskell you can create a tree data-structure with <code class='code'>data Tree a = Empty | Branch a (Tree a) (Tree a)    deriving Show</code>"
			],
			"examples": [
				{"input": "FN (Branch 'x' (Branch 'x' Empty Empty) Empty)", "output": "False"},
				{"input": "FN (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))", "output": "True"}
			]
		}
	}
    },
    "57": {
        "description": "Construct a binary search tree (dictionary) of minimum depth from a list of numbers.  Information about binary search trees can be found <a href='https://en.wikipedia.org/wiki/Binary_search_tree'>on Wikipedia</a>.\n",
        "difficulty": 2,
        "function-name": "construct tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "58": {
        "description": "Construct all completely balanced, symmetric binary trees of a given size.",
        "difficulty": 2,
        "function-name": "balanced symmetric trees",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "59": {
        "description": "Given a height, construct all height-balanced binary trees of that height.  In a height-balanced binary tree, the following property holds for every node: The height of its left subtree and the height of its right subtree are almost equal, which means their difference is not greater than one.",
        "difficulty": 2,
        "function-name": "height balanced trees of height",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "60": {
        "description": "Given a number of nodes, construct all height-balanced binary trees with that number of nodes.",
        "difficulty": 2,
        "function-name": "height balanced trees",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "61a": {
        "description": "Count the leaves of a binary tree",
        "difficulty": 1,
        "function-name": "count leaves",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "61b": {
        "description": "Find the leaves of a binary tree.",
        "difficulty": 1,
        "function-name": "leaves",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "62a": {
        "description": "Find the internal nodes of a binary tree.  That is, all of the non-leaf nodes.",
        "difficulty": 1,
        "function-name": "nodes",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "62b": {
        "description": "Find the nodes at a given height in a tree.",
        "difficulty": 1,
        "function-name": "nodes at height",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "63": {
        "description": "Construct a complete binary tree\n",
        "difficulty": 2,
        "function-name": "complete tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "64": {
        "description": "Given a binary tree as the usual Prolog term t(X,L,R) (or nil). As a preparation for drawing the tree, a layout algorithm is required to determine the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is shown in the illustration below:\n",
        "difficulty": 2,
        "function-name": "layout tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "65": {
        "description": "An alternative layout method is depicted in the illustration below:\n",
        "difficulty": 2,
        "function-name": "layout tree spaced",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "66": {
        "description": "Yet another layout strategy is shown in the illustration below:\n",
        "difficulty": 3,
        "function-name": "layout tree compact",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "67A": {
        "description": "A string representation of binary trees\n",
        "difficulty": 2,
        "function-name": "tree to string",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "68": {
        "description": "Preorder and inorder sequences of binary trees. We consider binary trees with nodes that are identified by single lower-case letters, as in the example of problem P67.\n",
        "difficulty": 2,
        "function-name": "",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "69": {
        "description": "Dotstring representation of binary trees.\n",
        "difficulty": 2,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "70": {
        "description": "(**) Tree construction from a node string.\n",
        "difficulty": null,
        "function-name": "",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "70B": {
        "description": "(*) Check whether a given term represents a multiway tree.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "70C": {
        "description": "(*) Count the nodes of a multiway tree.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "71": {
        "description": "(*) Determine the internal path length of a tree.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "72": {
        "description": "(*) Construct the bottom-up order sequence of the tree nodes.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "73": {
        "description": "(**) Lisp-like tree representation.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "80": {
        "description": "(***) Conversions\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "81": {
        "description": "(**) Path from one node to another one\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "82": {
        "description": "(*) Cycle from a given node\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "83": {
        "description": "(**) Construct all spanning trees \n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "84": {
        "description": "(**) Construct the minimal spanning tree\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "85": {
        "description": "(**) Graph isomorphism\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "86": {
        "description": "(**) Node degree and graph coloration\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "87": {
        "description": "(**) Depth-first order graph traversal (alternative solution)\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "88": {
        "description": "(**) Connected components (alternative solution)\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "89": {
        "description": "(**) Bipartite graphs\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "90": {
        "description": "(**) Eight queens problem\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "91": {
        "description": "(**) Knight's tour\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "92": {
        "description": "(***) Von Koch's conjecture\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "93": {
        "description": "(***) An arithmetic puzzle\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "94": {
        "description": "(***) Generate K-regular simple graphs with N nodes\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "95": {
        "description": "(**) English number words\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "96": {
        "description": "(**) Syntax checker\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "97": {
        "description": "(**) Sudoku\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "98": {
        "description": "(***) Nonograms\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "99": {
        "description": "(***) Crossword puzzle\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    }
}
